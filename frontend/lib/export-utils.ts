/**
 * Export utilities for downloading content as different file formats
 * Supports: Markdown (.md), PDF (.pdf), Word (.docx)
 * 
 * Features:
 * - Headers (H1, H2, H3)
 * - Bold and italic text
 * - Bullet and numbered lists
 * - Tables (PDF: styled HTML tables, Word: native tables)
 * - Compact layout optimized for professional documents
 * 
 * v2.0 - December 2025: Improved PDF/Word formatting
 * - Reduced whitespace and margins
 * - Compact table styling
 * - Better handling of empty lines
 * - Professional document appearance
 */

import { saveAs } from 'file-saver'
import { 
  Document, 
  Packer, 
  Paragraph, 
  TextRun,
  HeadingLevel,
  AlignmentType,
  convertInchesToTwip,
  Table,
  TableRow,
  TableCell,
  WidthType,
  BorderStyle
} from 'docx'

/**
 * Sanitize filename - remove special characters and spaces
 */
function sanitizeFilename(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]/g, '_')
    .replace(/_+/g, '_')
    .replace(/^_|_$/g, '')
}

/**
 * Export content as Markdown file
 */
export function exportAsMarkdown(content: string, companyName: string): void {
  const filename = `${sanitizeFilename(companyName)}_brief.md`
  const blob = new Blob([content], { type: 'text/markdown;charset=utf-8' })
  saveAs(blob, filename)
}

/**
 * Export content as PDF file
 * Uses html2pdf.js for conversion
 * 
 * v2.0: Improved styling with compact layout
 */
export async function exportAsPdf(
  content: string, 
  companyName: string,
  title: string
): Promise<void> {
  // Dynamic import to avoid SSR issues
  const html2pdf = (await import('html2pdf.js')).default
  
  // Convert markdown to styled HTML (compact mode)
  const htmlContent = markdownToHtml(content)
  
  // Create a styled container with compact layout
  const container = document.createElement('div')
  container.innerHTML = `
    <div style="font-family: 'Segoe UI', Arial, sans-serif; padding: 25px 30px; max-width: 100%;">
      <div style="border-bottom: 2px solid #3b82f6; padding-bottom: 12px; margin-bottom: 16px;">
        <h1 style="color: #1e293b; font-size: 22px; margin: 0 0 4px 0; font-weight: 600;">${title}</h1>
        <p style="color: #64748b; font-size: 11px; margin: 0;">Research Brief • ${new Date().toLocaleDateString()}</p>
      </div>
      <div style="color: #334155; line-height: 1.5; font-size: 11px;">
        ${htmlContent}
      </div>
      <div style="margin-top: 24px; padding-top: 12px; border-top: 1px solid #e2e8f0; color: #94a3b8; font-size: 9px; text-align: center;">
        Generated by DealMotion • ${new Date().toLocaleDateString()}
      </div>
    </div>
  `
  
  const filename = `${sanitizeFilename(companyName)}_brief.pdf`
  
  const options = {
    margin: [8, 10, 8, 10], // top, right, bottom, left in mm
    filename: filename,
    image: { type: 'jpeg', quality: 0.98 },
    html2canvas: { scale: 2, useCORS: true, logging: false },
    jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' as const },
    pagebreak: { mode: ['avoid-all', 'css', 'legacy'] }
  }
  
  await html2pdf().set(options).from(container).save()
}

/**
 * Export content as Word document (.docx)
 * Uses docx library for generation
 * 
 * v2.0: Compact layout with professional styling
 * - Reduced font sizes (11pt base)
 * - Tighter spacing between elements
 * - Better table formatting
 */
export async function exportAsDocx(
  content: string, 
  companyName: string,
  title: string
): Promise<void> {
  // Document children (can be Paragraph or Table)
  const children: (Paragraph | Table)[] = []
  
  // Title - compact blue header
  children.push(
    new Paragraph({
      children: [
        new TextRun({
          text: title,
          bold: true,
          size: 36, // 18pt
          color: '1e40af', // Blue
        }),
      ],
      heading: HeadingLevel.TITLE,
      spacing: { after: 60 },
    })
  )
  
  // Subtitle - gray text with blue underline
  children.push(
    new Paragraph({
      children: [
        new TextRun({
          text: `Research Brief • ${new Date().toLocaleDateString()}`,
          size: 20, // 10pt
          color: '64748b', // Gray
        }),
      ],
      spacing: { after: 120 },
      border: {
        bottom: { style: BorderStyle.SINGLE, size: 8, color: '3b82f6' }
      }
    })
  )
  
  // Parse content - skip empty lines entirely, use element spacing instead
  const lines = content.split('\n')
  let i = 0
  
  while (i < lines.length) {
    const line = lines[i]
    const trimmedLine = line.trim()
    
    // Skip empty lines entirely - spacing is handled by elements
    if (!trimmedLine) {
      i++
      continue
    }
    
    // Skip horizontal rules
    if (/^-{3,}$/.test(trimmedLine) || /^\*{3,}$/.test(trimmedLine)) {
      i++
      continue
    }
    
    // Check if this is the start of a table
    if (trimmedLine.includes('|') && i + 1 < lines.length && lines[i + 1].includes('|') && lines[i + 1].includes('-')) {
      // Collect all table lines
      const tableLines: string[] = []
      while (i < lines.length && lines[i].includes('|')) {
        tableLines.push(lines[i])
        i++
      }
      
      // Create Word table with small spacing after
      const table = createWordTable(tableLines)
      if (table) {
        children.push(table)
        // Add a small spacer after table (like a soft return)
        children.push(new Paragraph({ spacing: { after: 60 } }))
      }
      continue
    }
    
    // H1 - main section headers
    if (trimmedLine.startsWith('# ') && !trimmedLine.startsWith('## ')) {
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: trimmedLine.slice(2),
              bold: true,
              size: 28, // 14pt
              color: '1e293b',
            }),
          ],
          heading: HeadingLevel.HEADING_1,
          spacing: { before: 160, after: 60 },
        })
      )
    }
    // H2 - subsection headers with underline
    else if (trimmedLine.startsWith('## ') && !trimmedLine.startsWith('### ')) {
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: trimmedLine.slice(3),
              bold: true,
              size: 24, // 12pt
              color: '334155',
            }),
          ],
          heading: HeadingLevel.HEADING_2,
          spacing: { before: 140, after: 40 },
          border: {
            bottom: { style: BorderStyle.SINGLE, size: 4, color: 'e2e8f0' }
          }
        })
      )
    }
    // H3 - minor headers
    else if (trimmedLine.startsWith('### ')) {
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: trimmedLine.slice(4),
              bold: true,
              size: 22, // 11pt
              color: '475569',
            }),
          ],
          heading: HeadingLevel.HEADING_3,
          spacing: { before: 100, after: 30 },
        })
      )
    }
    // H4 - smallest headers
    else if (trimmedLine.startsWith('#### ')) {
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: trimmedLine.slice(5),
              bold: true,
              size: 20, // 10pt
              color: '64748b',
            }),
          ],
          spacing: { before: 80, after: 30 },
        })
      )
    }
    // Bullet point - small gap between items
    else if (trimmedLine.startsWith('- ') || trimmedLine.startsWith('* ')) {
      children.push(
        new Paragraph({
          children: parseFormattedText(trimmedLine.slice(2)),
          bullet: { level: 0 },
          spacing: { after: 20 }, // Small gap between list items
          indent: { left: convertInchesToTwip(0.2) },
        })
      )
    }
    // Numbered list - small gap between items
    else if (/^\d+\.\s/.test(trimmedLine)) {
      const num = trimmedLine.match(/^\d+/)?.[0] || '1'
      const text = trimmedLine.replace(/^\d+\.\s/, '')
      children.push(
        new Paragraph({
          children: [
            new TextRun({ text: num + '. ', bold: true, size: 22 }),
            ...parseFormattedText(text),
          ],
          spacing: { after: 20 }, // Small gap between list items
          indent: { left: convertInchesToTwip(0.2) },
        })
      )
    }
    // Regular paragraph - balanced spacing
    else {
      children.push(
        new Paragraph({
          children: parseFormattedText(trimmedLine),
          spacing: { after: 60 },
        })
      )
    }
    
    i++
  }
  
  // Footer - centered, gray, italic (no spacer, just top border)
  children.push(
    new Paragraph({
      children: [
        new TextRun({
          text: `Generated by DealMotion • ${new Date().toLocaleDateString()}`,
          size: 18, // 9pt
          italics: true,
          color: '94a3b8',
        }),
      ],
      alignment: AlignmentType.CENTER,
      spacing: { before: 120 },
      border: {
        top: { style: BorderStyle.SINGLE, size: 4, color: 'e2e8f0' }
      }
    })
  )
  
  // Create document with compact styling
  const doc = new Document({
    styles: {
      default: {
        document: {
          run: {
            font: 'Calibri',
            size: 22, // 11pt base font
          },
        },
      },
    },
    sections: [
      {
        properties: {
          page: {
            margin: {
              top: convertInchesToTwip(0.6),
              right: convertInchesToTwip(0.6),
              bottom: convertInchesToTwip(0.6),
              left: convertInchesToTwip(0.6),
            },
          },
        },
        children: children,
      },
    ],
  })
  
  // Generate and save
  const buffer = await Packer.toBlob(doc)
  const filename = `${sanitizeFilename(companyName)}_brief.docx`
  saveAs(buffer, filename)
}

/**
 * Create a Word Table from markdown table lines
 * v2.0: Compact table styling with smaller cells
 */
function createWordTable(tableLines: string[]): Table | null {
  if (tableLines.length < 2) return null
  
  // Parse header row
  const headerLine = tableLines[0]
  const headers = headerLine
    .split('|')
    .map(cell => cell.trim())
    .filter(cell => cell.length > 0)
  
  if (headers.length === 0) return null
  
  // Parse data rows (skip separator line at index 1)
  const dataRows: string[][] = []
  for (let i = 2; i < tableLines.length; i++) {
    const line = tableLines[i]
    if (!line.includes('|')) break
    if (/^[\s\-|:]+$/.test(line.trim())) continue // Skip separator lines
    
    const cells = line
      .split('|')
      .map(cell => cell.trim())
      .filter(cell => cell !== '')
    
    if (cells.length > 0) {
      dataRows.push(cells)
    }
  }
  
  // Calculate column width - auto-fit based on content
  // Use AUTO width type so Word can auto-size columns
  const colWidth = Math.floor(9000 / headers.length)
  
  // Create table rows
  const rows: TableRow[] = []
  
  // Header row with subtle gray background (not too dark)
  rows.push(
    new TableRow({
      tableHeader: true,
      children: headers.map(header => 
        new TableCell({
          width: { size: colWidth, type: WidthType.DXA },
          shading: { fill: 'f1f5f9' }, // Light gray background
          children: [
            new Paragraph({
              spacing: { before: 40, after: 40 },
              children: [
                new TextRun({
                  text: header.replace(/\*\*/g, '').replace(/\*/g, ''),
                  bold: true,
                  size: 20, // 10pt
                  color: '1e293b',
                }),
              ],
            }),
          ],
        })
      ),
    })
  )
  
  // Data rows with alternating colors
  for (let rowIdx = 0; rowIdx < dataRows.length; rowIdx++) {
    const row = dataRows[rowIdx]
    const isEvenRow = rowIdx % 2 === 0
    
    rows.push(
      new TableRow({
        children: row.map(cell =>
          new TableCell({
            width: { size: colWidth, type: WidthType.DXA },
            shading: { fill: isEvenRow ? 'ffffff' : 'f8fafc' },
            children: [
              new Paragraph({
                spacing: { before: 30, after: 30 },
                children: parseFormattedText(cell, 20), // 10pt font
              }),
            ],
          })
        ),
      })
    )
  }
  
  // Create table with subtle borders - not full width
  return new Table({
    width: { size: 100, type: WidthType.PERCENTAGE },
    rows: rows,
    borders: {
      top: { style: BorderStyle.SINGLE, size: 4, color: 'cbd5e1' },
      bottom: { style: BorderStyle.SINGLE, size: 4, color: 'cbd5e1' },
      left: { style: BorderStyle.SINGLE, size: 4, color: 'cbd5e1' },
      right: { style: BorderStyle.SINGLE, size: 4, color: 'cbd5e1' },
      insideHorizontal: { style: BorderStyle.SINGLE, size: 2, color: 'e2e8f0' },
      insideVertical: { style: BorderStyle.SINGLE, size: 2, color: 'e2e8f0' },
    },
  })
}

/**
 * Parse text with bold/italic markdown formatting into TextRuns
 * @param text - The markdown text to parse
 * @param fontSize - Font size in half-points (default 22 = 11pt)
 */
function parseFormattedText(text: string, fontSize: number = 22): TextRun[] {
  const runs: TextRun[] = []
  const parts = text.split(/(\*\*.*?\*\*|\*.*?\*)/g)
  
  for (const part of parts) {
    if (!part) continue
    
    if (part.startsWith('**') && part.endsWith('**')) {
      runs.push(new TextRun({
        text: part.slice(2, -2),
        bold: true,
        size: fontSize,
      }))
    } else if (part.startsWith('*') && part.endsWith('*')) {
      runs.push(new TextRun({
        text: part.slice(1, -1),
        italics: true,
        size: fontSize,
      }))
    } else {
      runs.push(new TextRun({
        text: part,
        size: fontSize,
      }))
    }
  }
  
  return runs.length > 0 ? runs : [new TextRun({ text, size: fontSize })]
}

// ============================================================
// PDF Export Helpers
// ============================================================

/**
 * Parse markdown tables and return array of table objects
 */
interface ParsedTable {
  headers: string[]
  rows: string[][]
}

function parseMarkdownTable(tableLines: string[]): ParsedTable | null {
  if (tableLines.length < 2) return null
  
  // Parse header row
  const headerLine = tableLines[0]
  const headers = headerLine
    .split('|')
    .map(cell => cell.trim())
    .filter(cell => cell.length > 0)
  
  if (headers.length === 0) return null
  
  // Skip separator line (index 1) and parse data rows
  const rows: string[][] = []
  for (let i = 2; i < tableLines.length; i++) {
    const line = tableLines[i]
    if (!line.includes('|')) break
    
    const cells = line
      .split('|')
      .map(cell => cell.trim())
      .filter(cell => cell !== '')
    
    if (cells.length > 0) {
      rows.push(cells)
    }
  }
  
  return { headers, rows }
}

/**
 * Convert a parsed table to styled HTML
 * v2.0: Compact table styling with smaller padding and font
 */
function tableToHtml(table: ParsedTable): string {
  const tableStyle = `
    width: auto;
    border-collapse: collapse;
    margin: 8px 0 12px 0;
    font-size: 10px;
  `.replace(/\s+/g, ' ').trim()
  
  const thStyle = `
    background-color: #f1f5f9;
    border: 1px solid #cbd5e1;
    padding: 5px 8px;
    text-align: left;
    font-weight: 600;
    color: #1e293b;
    font-size: 10px;
    white-space: nowrap;
  `.replace(/\s+/g, ' ').trim()
  
  const tdStyle = `
    border: 1px solid #e2e8f0;
    padding: 4px 8px;
    color: #334155;
    font-size: 10px;
    vertical-align: top;
  `.replace(/\s+/g, ' ').trim()
  
  let html = `<table style="${tableStyle}">`
  
  // Header row
  html += '<thead><tr>'
  for (const header of table.headers) {
    const formattedHeader = header
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.*?)\*/g, '<em>$1</em>')
    html += `<th style="${thStyle}">${formattedHeader}</th>`
  }
  html += '</tr></thead>'
  
  // Data rows
  html += '<tbody>'
  for (const row of table.rows) {
    html += '<tr>'
    for (const cell of row) {
      const formattedCell = cell
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>')
      html += `<td style="${tdStyle}">${formattedCell}</td>`
    }
    html += '</tr>'
  }
  html += '</tbody>'
  
  html += '</table>'
  return html
}

/**
 * Convert markdown content to HTML for PDF generation
 * v2.0: Compact layout with minimal whitespace
 * 
 * Key improvements:
 * - Reduced margins on all elements
 * - Smaller font sizes
 * - Better handling of consecutive empty lines
 * - Compact list spacing
 */
function markdownToHtml(markdown: string): string {
  const lines = markdown.split('\n')
  const result: string[] = []
  let i = 0
  let lastWasEmpty = false
  let inList = false
  
  while (i < lines.length) {
    const line = lines[i]
    const trimmedLine = line.trim()
    
    // Check if this is the start of a table
    if (line.includes('|') && i + 1 < lines.length && lines[i + 1].includes('|') && lines[i + 1].includes('-')) {
      // Collect all table lines
      const tableLines: string[] = []
      while (i < lines.length && lines[i].includes('|')) {
        tableLines.push(lines[i])
        i++
      }
      
      // Parse and convert table
      const table = parseMarkdownTable(tableLines)
      if (table) {
        result.push(tableToHtml(table))
      } else {
        result.push(...tableLines)
      }
      lastWasEmpty = false
      inList = false
      continue
    }
    
    // Skip horizontal rules (---) but add minimal spacing
    if (/^-{3,}$/.test(trimmedLine) || /^\*{3,}$/.test(trimmedLine)) {
      result.push('<hr style="border: none; border-top: 1px solid #e2e8f0; margin: 8px 0;"/>')
      i++
      lastWasEmpty = false
      continue
    }
    
    // Process non-table line
    let processedLine = line
    
    // Headers - compact margins
    if (processedLine.startsWith('#### ')) {
      processedLine = `<h4 style="color: #334155; font-size: 11px; font-weight: 600; margin: 10px 0 4px 0;">${trimmedLine.slice(5)}</h4>`
      inList = false
    } else if (processedLine.startsWith('### ')) {
      processedLine = `<h3 style="color: #1e293b; font-size: 12px; font-weight: 600; margin: 12px 0 4px 0;">${trimmedLine.slice(4)}</h3>`
      inList = false
    } else if (processedLine.startsWith('## ')) {
      processedLine = `<h2 style="color: #1e293b; font-size: 14px; font-weight: 600; margin: 14px 0 6px 0; padding-bottom: 3px; border-bottom: 1px solid #e2e8f0;">${trimmedLine.slice(3)}</h2>`
      inList = false
    } else if (processedLine.startsWith('# ')) {
      processedLine = `<h1 style="color: #1e293b; font-size: 16px; font-weight: 700; margin: 16px 0 8px 0;">${trimmedLine.slice(2)}</h1>`
      inList = false
    } 
    // Bullet lists - compact
    else if (/^\s*[-*]\s+/.test(processedLine)) {
      const text = processedLine.replace(/^\s*[-*]\s+/, '')
      processedLine = `<li style="margin: 1px 0; padding-left: 4px;">${text}</li>`
      inList = true
    }
    // Numbered lists - compact
    else if (/^\d+\.\s+/.test(processedLine)) {
      const text = processedLine.replace(/^\d+\.\s+/, '')
      processedLine = `<li style="margin: 1px 0; padding-left: 4px;">${text}</li>`
      inList = true
    }
    // Empty lines - limit consecutive empty lines
    else if (trimmedLine === '') {
      if (!lastWasEmpty && !inList) {
        // Only add spacing if not consecutive and not in a list
        processedLine = ''
      } else {
        i++
        continue // Skip consecutive empty lines entirely
      }
      lastWasEmpty = true
      inList = false
      i++
      continue
    }
    // Bold text that starts a line (often a label) - make it a mini-header
    else if (/^\*\*[^*]+\*\*:/.test(trimmedLine)) {
      processedLine = `<p style="margin: 6px 0 2px 0;">${trimmedLine}</p>`
      inList = false
    }
    // Regular paragraphs - compact
    else if (!processedLine.startsWith('<')) {
      processedLine = `<p style="margin: 4px 0;">${trimmedLine}</p>`
      inList = false
    }
    
    // Apply inline formatting (bold/italic)
    processedLine = processedLine
      .replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>')
      .replace(/\*\*(.*?)\*\*/g, '<strong style="font-weight: 600;">$1</strong>')
      .replace(/\*(.*?)\*/g, '<em>$1</em>')
    
    result.push(processedLine)
    lastWasEmpty = trimmedLine === ''
    i++
  }
  
  // Wrap consecutive list items in ul with compact styling
  let html = result.join('\n')
  html = html.replace(/(<li[^>]*>.*?<\/li>\n?)+/g, (match) => {
    return `<ul style="margin: 4px 0 8px 0; padding-left: 16px; list-style-type: disc;">${match}</ul>`
  })
  
  // Clean up - remove empty paragraphs and excessive spacing
  html = html.replace(/<p style="[^"]*"><\/p>/g, '')
  html = html.replace(/\n{3,}/g, '\n\n')
  html = html.replace(/<\/ul>\s*<ul/g, '</ul><ul') // Merge adjacent lists
  
  return html
}
