/**
 * Export utilities for downloading content as different file formats
 * Supports: Markdown (.md), PDF (.pdf), Word (.docx)
 * 
 * Features:
 * - Headers (H1, H2, H3)
 * - Bold and italic text
 * - Bullet and numbered lists
 * - Tables with proper styling
 */

import { saveAs } from 'file-saver'
import { 
  Document, 
  Packer, 
  Paragraph, 
  TextRun, 
  HeadingLevel,
  AlignmentType,
  BorderStyle,
  Table,
  TableRow,
  TableCell,
  WidthType,
  VerticalAlign,
  ShadingType
} from 'docx'

/**
 * Sanitize filename - remove special characters and spaces
 */
function sanitizeFilename(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]/g, '_')
    .replace(/_+/g, '_')
    .replace(/^_|_$/g, '')
}

/**
 * Export content as Markdown file
 */
export function exportAsMarkdown(content: string, companyName: string): void {
  const filename = `${sanitizeFilename(companyName)}_brief.md`
  const blob = new Blob([content], { type: 'text/markdown;charset=utf-8' })
  saveAs(blob, filename)
}

/**
 * Export content as PDF file
 * Uses html2pdf.js for conversion
 */
export async function exportAsPdf(
  content: string, 
  companyName: string,
  title: string
): Promise<void> {
  // Dynamic import to avoid SSR issues
  const html2pdf = (await import('html2pdf.js')).default
  
  // Convert markdown to styled HTML
  const htmlContent = markdownToHtml(content)
  
  // Create a styled container
  const container = document.createElement('div')
  container.innerHTML = `
    <div style="font-family: 'Segoe UI', Arial, sans-serif; padding: 40px; max-width: 800px; margin: 0 auto;">
      <div style="border-bottom: 3px solid #3b82f6; padding-bottom: 20px; margin-bottom: 30px;">
        <h1 style="color: #1e293b; font-size: 28px; margin: 0 0 8px 0;">${title}</h1>
        <p style="color: #64748b; font-size: 14px; margin: 0;">Research Brief • ${new Date().toLocaleDateString()}</p>
      </div>
      <div style="color: #334155; line-height: 1.7; font-size: 14px;">
        ${htmlContent}
      </div>
      <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #e2e8f0; color: #94a3b8; font-size: 12px; text-align: center;">
        Generated by DealMotion • ${new Date().toLocaleDateString()}
      </div>
    </div>
  `
  
  const filename = `${sanitizeFilename(companyName)}_brief.pdf`
  
  const options = {
    margin: 10,
    filename: filename,
    image: { type: 'jpeg', quality: 0.98 },
    html2canvas: { scale: 2, useCORS: true },
    jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' as const }
  }
  
  await html2pdf().set(options).from(container).save()
}

/**
 * Export content as Word document (.docx)
 * Uses docx library for generation
 */
export async function exportAsDocx(
  content: string, 
  companyName: string,
  title: string
): Promise<void> {
  const children = parseMarkdownToDocxElements(content, title)
  
  const doc = new Document({
    styles: {
      paragraphStyles: [
        {
          id: 'Normal',
          name: 'Normal',
          basedOn: 'Normal',
          next: 'Normal',
          run: {
            font: 'Calibri',
            size: 24, // 12pt
          },
          paragraph: {
            spacing: { after: 200 },
          },
        },
      ],
    },
    sections: [
      {
        properties: {},
        children: children,
      },
    ],
  })
  
  const buffer = await Packer.toBlob(doc)
  const filename = `${sanitizeFilename(companyName)}_brief.docx`
  saveAs(buffer, filename)
}

// ============================================================
// PDF Export Helpers
// ============================================================

/**
 * Parse markdown tables and return array of table objects
 */
interface ParsedTable {
  headers: string[]
  rows: string[][]
}

function parseMarkdownTable(tableLines: string[]): ParsedTable | null {
  if (tableLines.length < 2) return null
  
  // Parse header row
  const headerLine = tableLines[0]
  const headers = headerLine
    .split('|')
    .map(cell => cell.trim())
    .filter(cell => cell.length > 0)
  
  if (headers.length === 0) return null
  
  // Skip separator line (index 1) and parse data rows
  const rows: string[][] = []
  for (let i = 2; i < tableLines.length; i++) {
    const line = tableLines[i]
    if (!line.includes('|')) break
    
    const cells = line
      .split('|')
      .map(cell => cell.trim())
      .filter(cell => cell !== '')
    
    if (cells.length > 0) {
      rows.push(cells)
    }
  }
  
  return { headers, rows }
}

/**
 * Convert a parsed table to styled HTML
 */
function tableToHtml(table: ParsedTable): string {
  const tableStyle = `
    width: 100%;
    border-collapse: collapse;
    margin: 16px 0;
    font-size: 13px;
  `.replace(/\s+/g, ' ').trim()
  
  const thStyle = `
    background-color: #f8fafc;
    border: 1px solid #e2e8f0;
    padding: 10px 12px;
    text-align: left;
    font-weight: 600;
    color: #1e293b;
  `.replace(/\s+/g, ' ').trim()
  
  const tdStyle = `
    border: 1px solid #e2e8f0;
    padding: 10px 12px;
    color: #334155;
  `.replace(/\s+/g, ' ').trim()
  
  let html = `<table style="${tableStyle}">`
  
  // Header row
  html += '<thead><tr>'
  for (const header of table.headers) {
    // Parse bold/italic in header
    const formattedHeader = header
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.*?)\*/g, '<em>$1</em>')
    html += `<th style="${thStyle}">${formattedHeader}</th>`
  }
  html += '</tr></thead>'
  
  // Data rows
  html += '<tbody>'
  for (const row of table.rows) {
    html += '<tr>'
    for (const cell of row) {
      // Parse bold/italic in cells
      const formattedCell = cell
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>')
      html += `<td style="${tdStyle}">${formattedCell}</td>`
    }
    html += '</tr>'
  }
  html += '</tbody>'
  
  html += '</table>'
  return html
}

/**
 * Convert markdown content to HTML for PDF generation
 * Now includes table support
 */
function markdownToHtml(markdown: string): string {
  const lines = markdown.split('\n')
  const result: string[] = []
  let i = 0
  
  while (i < lines.length) {
    const line = lines[i]
    
    // Check if this is the start of a table
    if (line.includes('|') && i + 1 < lines.length && lines[i + 1].includes('|') && lines[i + 1].includes('-')) {
      // Collect all table lines
      const tableLines: string[] = []
      while (i < lines.length && lines[i].includes('|')) {
        tableLines.push(lines[i])
        i++
      }
      
      // Parse and convert table
      const table = parseMarkdownTable(tableLines)
      if (table) {
        result.push(tableToHtml(table))
      } else {
        // If parsing failed, just output as text
        result.push(...tableLines)
      }
      continue
    }
    
    // Process non-table line
    let processedLine = line
    
    // Headers
    if (processedLine.startsWith('### ')) {
      processedLine = `<h3 style="color: #1e293b; font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">${processedLine.slice(4)}</h3>`
    } else if (processedLine.startsWith('## ')) {
      processedLine = `<h2 style="color: #1e293b; font-size: 20px; font-weight: 600; margin: 28px 0 16px 0; padding-bottom: 8px; border-bottom: 1px solid #e2e8f0;">${processedLine.slice(3)}</h2>`
    } else if (processedLine.startsWith('# ')) {
      processedLine = `<h1 style="color: #1e293b; font-size: 24px; font-weight: 700; margin: 32px 0 16px 0;">${processedLine.slice(2)}</h1>`
    } 
    // Bullet lists
    else if (/^\s*[-*]\s+/.test(processedLine)) {
      const text = processedLine.replace(/^\s*[-*]\s+/, '')
      processedLine = `<li style="margin: 4px 0; margin-left: 20px;">${text}</li>`
    }
    // Numbered lists
    else if (/^\d+\.\s+/.test(processedLine)) {
      const text = processedLine.replace(/^\d+\.\s+/, '')
      processedLine = `<li style="margin: 4px 0; margin-left: 20px;">${text}</li>`
    }
    // Empty lines
    else if (processedLine.trim() === '') {
      processedLine = '<br/>'
    }
    // Regular paragraphs
    else if (!processedLine.startsWith('<')) {
      processedLine = `<p style="margin: 12px 0;">${processedLine}</p>`
    }
    
    // Apply inline formatting (bold/italic)
    processedLine = processedLine
      .replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>')
      .replace(/\*\*(.*?)\*\*/g, '<strong style="font-weight: 600;">$1</strong>')
      .replace(/\*(.*?)\*/g, '<em>$1</em>')
    
    result.push(processedLine)
    i++
  }
  
  // Wrap consecutive list items in ul
  let html = result.join('\n')
  html = html.replace(/(<li[^>]*>.*?<\/li>\n?)+/g, (match) => {
    return `<ul style="margin: 12px 0; padding-left: 0;">${match}</ul>`
  })
  
  // Clean up
  html = html.replace(/<br\/>\s*<br\/>/g, '<br/>')
  html = html.replace(/<p style="margin: 12px 0;"><\/p>/g, '')
  
  return html
}

// ============================================================
// Word Export Helpers
// ============================================================

/**
 * Convert a parsed markdown table to a docx Table
 */
function createDocxTable(table: ParsedTable): Table {
  const borderStyle = {
    style: BorderStyle.SINGLE,
    size: 8,
    color: 'e2e8f0',
  }
  
  const rows: TableRow[] = []
  
  // Header row
  const headerCells = table.headers.map(header => {
    return new TableCell({
      children: [
        new Paragraph({
          children: parseTextWithFormatting(header.replace(/\*\*/g, '')), // Remove bold markers, will be styled
          spacing: { after: 0 },
        }),
      ],
      shading: {
        type: ShadingType.SOLID,
        color: 'f8fafc',
        fill: 'f8fafc',
      },
      verticalAlign: VerticalAlign.CENTER,
      margins: {
        top: 100,
        bottom: 100,
        left: 120,
        right: 120,
      },
      borders: {
        top: borderStyle,
        bottom: borderStyle,
        left: borderStyle,
        right: borderStyle,
      },
    })
  })
  
  rows.push(new TableRow({
    children: headerCells,
    tableHeader: true,
  }))
  
  // Data rows
  for (const rowData of table.rows) {
    const cells = rowData.map(cellText => {
      return new TableCell({
        children: [
          new Paragraph({
            children: parseTextWithFormatting(cellText),
            spacing: { after: 0 },
          }),
        ],
        verticalAlign: VerticalAlign.CENTER,
        margins: {
          top: 80,
          bottom: 80,
          left: 120,
          right: 120,
        },
        borders: {
          top: borderStyle,
          bottom: borderStyle,
          left: borderStyle,
          right: borderStyle,
        },
      })
    })
    
    rows.push(new TableRow({ children: cells }))
  }
  
  return new Table({
    rows: rows,
    width: {
      size: 100,
      type: WidthType.PERCENTAGE,
    },
  })
}

/**
 * Parse markdown content into docx elements (paragraphs and tables)
 */
function parseMarkdownToDocxElements(content: string, title: string): (Paragraph | Table)[] {
  const elements: (Paragraph | Table)[] = []
  
  // Title
  elements.push(
    new Paragraph({
      children: [
        new TextRun({
          text: title,
          bold: true,
          size: 56, // 28pt
          color: '1e293b',
        }),
      ],
      spacing: { after: 100 },
    })
  )
  
  // Subtitle
  elements.push(
    new Paragraph({
      children: [
        new TextRun({
          text: `Research Brief • ${new Date().toLocaleDateString()}`,
          size: 24, // 12pt
          color: '64748b',
        }),
      ],
      spacing: { after: 400 },
      border: {
        bottom: {
          color: '3b82f6',
          space: 10,
          style: BorderStyle.SINGLE,
          size: 24,
        },
      },
    })
  )
  
  // Parse content lines
  const lines = content.split('\n')
  let i = 0
  
  while (i < lines.length) {
    const line = lines[i]
    const trimmedLine = line.trim()
    
    // Check if this is the start of a table
    if (trimmedLine.includes('|') && i + 1 < lines.length && lines[i + 1].includes('|') && lines[i + 1].includes('-')) {
      // Collect all table lines
      const tableLines: string[] = []
      while (i < lines.length && lines[i].includes('|')) {
        tableLines.push(lines[i])
        i++
      }
      
      // Parse and create table
      const table = parseMarkdownTable(tableLines)
      if (table) {
        // Add some spacing before table
        elements.push(new Paragraph({ children: [], spacing: { after: 100 } }))
        elements.push(createDocxTable(table))
        // Add some spacing after table
        elements.push(new Paragraph({ children: [], spacing: { after: 200 } }))
      }
      continue
    }
    
    // Empty line
    if (!trimmedLine) {
      elements.push(new Paragraph({ children: [] }))
      i++
      continue
    }
    
    // H1
    if (trimmedLine.startsWith('# ')) {
      elements.push(
        new Paragraph({
          children: [
            new TextRun({
              text: trimmedLine.replace(/^# /, ''),
              bold: true,
              size: 48, // 24pt
            }),
          ],
          heading: HeadingLevel.HEADING_1,
          spacing: { before: 400, after: 200 },
        })
      )
      i++
      continue
    }
    
    // H2
    if (trimmedLine.startsWith('## ')) {
      elements.push(
        new Paragraph({
          children: [
            new TextRun({
              text: trimmedLine.replace(/^## /, ''),
              bold: true,
              size: 36, // 18pt
            }),
          ],
          heading: HeadingLevel.HEADING_2,
          spacing: { before: 300, after: 150 },
          border: {
            bottom: {
              color: 'e2e8f0',
              space: 5,
              style: BorderStyle.SINGLE,
              size: 8,
            },
          },
        })
      )
      i++
      continue
    }
    
    // H3
    if (trimmedLine.startsWith('### ')) {
      elements.push(
        new Paragraph({
          children: [
            new TextRun({
              text: trimmedLine.replace(/^### /, ''),
              bold: true,
              size: 28, // 14pt
            }),
          ],
          heading: HeadingLevel.HEADING_3,
          spacing: { before: 200, after: 100 },
        })
      )
      i++
      continue
    }
    
    // Bullet points
    if (trimmedLine.startsWith('- ') || trimmedLine.startsWith('* ')) {
      const text = trimmedLine.replace(/^[-*] /, '')
      elements.push(
        new Paragraph({
          children: parseTextWithFormatting(text),
          bullet: { level: 0 },
          spacing: { after: 80 },
        })
      )
      i++
      continue
    }
    
    // Numbered lists
    if (/^\d+\. /.test(trimmedLine)) {
      const text = trimmedLine.replace(/^\d+\. /, '')
      elements.push(
        new Paragraph({
          children: parseTextWithFormatting(text),
          numbering: { reference: 'default-numbering', level: 0 },
          spacing: { after: 80 },
        })
      )
      i++
      continue
    }
    
    // Regular paragraph
    elements.push(
      new Paragraph({
        children: parseTextWithFormatting(trimmedLine),
        spacing: { after: 150 },
      })
    )
    i++
  }
  
  // Footer
  elements.push(
    new Paragraph({
      children: [
        new TextRun({
          text: `Generated by DealMotion • ${new Date().toLocaleDateString()}`,
          size: 20, // 10pt
          color: '94a3b8',
          italics: true,
        }),
      ],
      alignment: AlignmentType.CENTER,
      spacing: { before: 600 },
      border: {
        top: {
          color: 'e2e8f0',
          space: 10,
          style: BorderStyle.SINGLE,
          size: 8,
        },
      },
    })
  )
  
  return elements
}

/**
 * Parse text with bold/italic formatting into TextRuns
 */
function parseTextWithFormatting(text: string): TextRun[] {
  const runs: TextRun[] = []
  
  // Simple regex-based parsing for bold and italic
  const parts = text.split(/(\*\*.*?\*\*|\*.*?\*)/g)
  
  for (const part of parts) {
    if (!part) continue
    
    if (part.startsWith('**') && part.endsWith('**')) {
      runs.push(
        new TextRun({
          text: part.slice(2, -2),
          bold: true,
          size: 24,
        })
      )
    } else if (part.startsWith('*') && part.endsWith('*')) {
      runs.push(
        new TextRun({
          text: part.slice(1, -1),
          italics: true,
          size: 24,
        })
      )
    } else {
      runs.push(
        new TextRun({
          text: part,
          size: 24,
        })
      )
    }
  }
  
  return runs.length > 0 ? runs : [new TextRun({ text, size: 24 })]
}
