/**
 * Export utilities for downloading content as different file formats
 * Supports: Markdown (.md), PDF (.pdf), Word (.docx)
 * 
 * Features:
 * - Headers (H1, H2, H3)
 * - Bold and italic text
 * - Bullet and numbered lists
 * - Tables (PDF: styled HTML tables, Word: plain text)
 */

import { saveAs } from 'file-saver'
import { 
  Document, 
  Packer, 
  Paragraph, 
  TextRun
} from 'docx'

/**
 * Sanitize filename - remove special characters and spaces
 */
function sanitizeFilename(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]/g, '_')
    .replace(/_+/g, '_')
    .replace(/^_|_$/g, '')
}

/**
 * Export content as Markdown file
 */
export function exportAsMarkdown(content: string, companyName: string): void {
  const filename = `${sanitizeFilename(companyName)}_brief.md`
  const blob = new Blob([content], { type: 'text/markdown;charset=utf-8' })
  saveAs(blob, filename)
}

/**
 * Export content as PDF file
 * Uses html2pdf.js for conversion
 */
export async function exportAsPdf(
  content: string, 
  companyName: string,
  title: string
): Promise<void> {
  // Dynamic import to avoid SSR issues
  const html2pdf = (await import('html2pdf.js')).default
  
  // Convert markdown to styled HTML
  const htmlContent = markdownToHtml(content)
  
  // Create a styled container
  const container = document.createElement('div')
  container.innerHTML = `
    <div style="font-family: 'Segoe UI', Arial, sans-serif; padding: 40px; max-width: 800px; margin: 0 auto;">
      <div style="border-bottom: 3px solid #3b82f6; padding-bottom: 20px; margin-bottom: 30px;">
        <h1 style="color: #1e293b; font-size: 28px; margin: 0 0 8px 0;">${title}</h1>
        <p style="color: #64748b; font-size: 14px; margin: 0;">Research Brief • ${new Date().toLocaleDateString()}</p>
      </div>
      <div style="color: #334155; line-height: 1.7; font-size: 14px;">
        ${htmlContent}
      </div>
      <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #e2e8f0; color: #94a3b8; font-size: 12px; text-align: center;">
        Generated by DealMotion • ${new Date().toLocaleDateString()}
      </div>
    </div>
  `
  
  const filename = `${sanitizeFilename(companyName)}_brief.pdf`
  
  const options = {
    margin: 10,
    filename: filename,
    image: { type: 'jpeg', quality: 0.98 },
    html2canvas: { scale: 2, useCORS: true },
    jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' as const }
  }
  
  await html2pdf().set(options).from(container).save()
}

/**
 * Export content as Word document (.docx)
 * Uses docx library for generation - minimal version for compatibility
 */
export async function exportAsDocx(
  content: string, 
  companyName: string,
  title: string
): Promise<void> {
  // Create paragraphs array
  const paragraphs: Paragraph[] = []
  
  // Title
  paragraphs.push(
    new Paragraph({
      children: [
        new TextRun({
          text: title,
          bold: true,
          size: 48, // 24pt
        }),
      ],
    })
  )
  
  // Subtitle
  paragraphs.push(
    new Paragraph({
      children: [
        new TextRun({
          text: `Research Brief - ${new Date().toLocaleDateString()}`,
          size: 24, // 12pt
        }),
      ],
    })
  )
  
  // Empty line
  paragraphs.push(new Paragraph({}))
  
  // Content - split into paragraphs
  const lines = content.split('\n')
  for (const line of lines) {
    const trimmedLine = line.trim()
    
    if (!trimmedLine) {
      paragraphs.push(new Paragraph({}))
      continue
    }
    
    // Skip table separator lines
    if (/^[\s\-|:]+$/.test(trimmedLine)) {
      continue
    }
    
    // Headers
    if (trimmedLine.startsWith('### ')) {
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: trimmedLine.slice(4),
              bold: true,
              size: 28, // 14pt
            }),
          ],
        })
      )
    } else if (trimmedLine.startsWith('## ')) {
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: trimmedLine.slice(3),
              bold: true,
              size: 32, // 16pt
            }),
          ],
        })
      )
    } else if (trimmedLine.startsWith('# ')) {
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: trimmedLine.slice(2),
              bold: true,
              size: 40, // 20pt
            }),
          ],
        })
      )
    } else if (trimmedLine.startsWith('- ') || trimmedLine.startsWith('* ')) {
      // Bullet point
      const text = trimmedLine.slice(2).replace(/\*\*/g, '').replace(/\*/g, '')
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: '• ' + text,
              size: 24,
            }),
          ],
        })
      )
    } else if (/^\d+\.\s/.test(trimmedLine)) {
      // Numbered list
      const text = trimmedLine.replace(/^\d+\.\s/, '').replace(/\*\*/g, '').replace(/\*/g, '')
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: trimmedLine.match(/^\d+/)?.[0] + '. ' + text,
              size: 24,
            }),
          ],
        })
      )
    } else if (trimmedLine.includes('|')) {
      // Table row - render as formatted text with pipe separators
      const cleanRow = trimmedLine
        .split('|')
        .map(cell => cell.trim())
        .filter(cell => cell.length > 0)
        .join('  |  ')
        .replace(/\*\*/g, '')
        .replace(/\*/g, '')
      
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: cleanRow,
              size: 22, // 11pt
            }),
          ],
        })
      )
    } else {
      // Regular paragraph - strip markdown formatting
      const text = trimmedLine.replace(/\*\*/g, '').replace(/\*/g, '')
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: text,
              size: 24,
            }),
          ],
        })
      )
    }
  }
  
  // Empty line before footer
  paragraphs.push(new Paragraph({}))
  
  // Footer
  paragraphs.push(
    new Paragraph({
      children: [
        new TextRun({
          text: `Generated by DealMotion - ${new Date().toLocaleDateString()}`,
          size: 20, // 10pt
          italics: true,
        }),
      ],
    })
  )
  
  // Create document with minimal configuration
  const doc = new Document({
    sections: [
      {
        children: paragraphs,
      },
    ],
  })
  
  // Generate and save
  const buffer = await Packer.toBlob(doc)
  const filename = `${sanitizeFilename(companyName)}_brief.docx`
  saveAs(buffer, filename)
}

// ============================================================
// PDF Export Helpers
// ============================================================

/**
 * Parse markdown tables and return array of table objects
 */
interface ParsedTable {
  headers: string[]
  rows: string[][]
}

function parseMarkdownTable(tableLines: string[]): ParsedTable | null {
  if (tableLines.length < 2) return null
  
  // Parse header row
  const headerLine = tableLines[0]
  const headers = headerLine
    .split('|')
    .map(cell => cell.trim())
    .filter(cell => cell.length > 0)
  
  if (headers.length === 0) return null
  
  // Skip separator line (index 1) and parse data rows
  const rows: string[][] = []
  for (let i = 2; i < tableLines.length; i++) {
    const line = tableLines[i]
    if (!line.includes('|')) break
    
    const cells = line
      .split('|')
      .map(cell => cell.trim())
      .filter(cell => cell !== '')
    
    if (cells.length > 0) {
      rows.push(cells)
    }
  }
  
  return { headers, rows }
}

/**
 * Convert a parsed table to styled HTML
 */
function tableToHtml(table: ParsedTable): string {
  const tableStyle = `
    width: 100%;
    border-collapse: collapse;
    margin: 16px 0;
    font-size: 13px;
  `.replace(/\s+/g, ' ').trim()
  
  const thStyle = `
    background-color: #f8fafc;
    border: 1px solid #e2e8f0;
    padding: 10px 12px;
    text-align: left;
    font-weight: 600;
    color: #1e293b;
  `.replace(/\s+/g, ' ').trim()
  
  const tdStyle = `
    border: 1px solid #e2e8f0;
    padding: 10px 12px;
    color: #334155;
  `.replace(/\s+/g, ' ').trim()
  
  let html = `<table style="${tableStyle}">`
  
  // Header row
  html += '<thead><tr>'
  for (const header of table.headers) {
    const formattedHeader = header
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.*?)\*/g, '<em>$1</em>')
    html += `<th style="${thStyle}">${formattedHeader}</th>`
  }
  html += '</tr></thead>'
  
  // Data rows
  html += '<tbody>'
  for (const row of table.rows) {
    html += '<tr>'
    for (const cell of row) {
      const formattedCell = cell
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>')
      html += `<td style="${tdStyle}">${formattedCell}</td>`
    }
    html += '</tr>'
  }
  html += '</tbody>'
  
  html += '</table>'
  return html
}

/**
 * Convert markdown content to HTML for PDF generation
 * Includes table support
 */
function markdownToHtml(markdown: string): string {
  const lines = markdown.split('\n')
  const result: string[] = []
  let i = 0
  
  while (i < lines.length) {
    const line = lines[i]
    
    // Check if this is the start of a table
    if (line.includes('|') && i + 1 < lines.length && lines[i + 1].includes('|') && lines[i + 1].includes('-')) {
      // Collect all table lines
      const tableLines: string[] = []
      while (i < lines.length && lines[i].includes('|')) {
        tableLines.push(lines[i])
        i++
      }
      
      // Parse and convert table
      const table = parseMarkdownTable(tableLines)
      if (table) {
        result.push(tableToHtml(table))
      } else {
        result.push(...tableLines)
      }
      continue
    }
    
    // Process non-table line
    let processedLine = line
    
    // Headers
    if (processedLine.startsWith('### ')) {
      processedLine = `<h3 style="color: #1e293b; font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">${processedLine.slice(4)}</h3>`
    } else if (processedLine.startsWith('## ')) {
      processedLine = `<h2 style="color: #1e293b; font-size: 20px; font-weight: 600; margin: 28px 0 16px 0; padding-bottom: 8px; border-bottom: 1px solid #e2e8f0;">${processedLine.slice(3)}</h2>`
    } else if (processedLine.startsWith('# ')) {
      processedLine = `<h1 style="color: #1e293b; font-size: 24px; font-weight: 700; margin: 32px 0 16px 0;">${processedLine.slice(2)}</h1>`
    } 
    // Bullet lists
    else if (/^\s*[-*]\s+/.test(processedLine)) {
      const text = processedLine.replace(/^\s*[-*]\s+/, '')
      processedLine = `<li style="margin: 4px 0; margin-left: 20px;">${text}</li>`
    }
    // Numbered lists
    else if (/^\d+\.\s+/.test(processedLine)) {
      const text = processedLine.replace(/^\d+\.\s+/, '')
      processedLine = `<li style="margin: 4px 0; margin-left: 20px;">${text}</li>`
    }
    // Empty lines
    else if (processedLine.trim() === '') {
      processedLine = '<br/>'
    }
    // Regular paragraphs
    else if (!processedLine.startsWith('<')) {
      processedLine = `<p style="margin: 12px 0;">${processedLine}</p>`
    }
    
    // Apply inline formatting (bold/italic)
    processedLine = processedLine
      .replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>')
      .replace(/\*\*(.*?)\*\*/g, '<strong style="font-weight: 600;">$1</strong>')
      .replace(/\*(.*?)\*/g, '<em>$1</em>')
    
    result.push(processedLine)
    i++
  }
  
  // Wrap consecutive list items in ul
  let html = result.join('\n')
  html = html.replace(/(<li[^>]*>.*?<\/li>\n?)+/g, (match) => {
    return `<ul style="margin: 12px 0; padding-left: 0;">${match}</ul>`
  })
  
  // Clean up
  html = html.replace(/<br\/>\s*<br\/>/g, '<br/>')
  html = html.replace(/<p style="margin: 12px 0;"><\/p>/g, '')
  
  return html
}
