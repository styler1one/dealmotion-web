/**
 * Export utilities for downloading content as different file formats
 * Supports: Markdown (.md), PDF (.pdf), Word (.docx)
 * 
 * Features:
 * - Headers (H1, H2, H3)
 * - Bold and italic text
 * - Bullet and numbered lists
 * - Tables (PDF: styled HTML tables, Word: plain text)
 */

import { saveAs } from 'file-saver'
import { 
  Document, 
  Packer, 
  Paragraph, 
  TextRun,
  HeadingLevel,
  AlignmentType,
  convertInchesToTwip,
  Table,
  TableRow,
  TableCell,
  WidthType,
  BorderStyle
} from 'docx'

/**
 * Sanitize filename - remove special characters and spaces
 */
function sanitizeFilename(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]/g, '_')
    .replace(/_+/g, '_')
    .replace(/^_|_$/g, '')
}

/**
 * Export content as Markdown file
 */
export function exportAsMarkdown(content: string, companyName: string): void {
  const filename = `${sanitizeFilename(companyName)}_brief.md`
  const blob = new Blob([content], { type: 'text/markdown;charset=utf-8' })
  saveAs(blob, filename)
}

/**
 * Export content as PDF file
 * Uses html2pdf.js for conversion
 */
export async function exportAsPdf(
  content: string, 
  companyName: string,
  title: string
): Promise<void> {
  // Dynamic import to avoid SSR issues
  const html2pdf = (await import('html2pdf.js')).default
  
  // Convert markdown to styled HTML
  const htmlContent = markdownToHtml(content)
  
  // Create a styled container
  const container = document.createElement('div')
  container.innerHTML = `
    <div style="font-family: 'Segoe UI', Arial, sans-serif; padding: 40px; max-width: 800px; margin: 0 auto;">
      <div style="border-bottom: 3px solid #3b82f6; padding-bottom: 20px; margin-bottom: 30px;">
        <h1 style="color: #1e293b; font-size: 28px; margin: 0 0 8px 0;">${title}</h1>
        <p style="color: #64748b; font-size: 14px; margin: 0;">Research Brief • ${new Date().toLocaleDateString()}</p>
      </div>
      <div style="color: #334155; line-height: 1.7; font-size: 14px;">
        ${htmlContent}
      </div>
      <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #e2e8f0; color: #94a3b8; font-size: 12px; text-align: center;">
        Generated by DealMotion • ${new Date().toLocaleDateString()}
      </div>
    </div>
  `
  
  const filename = `${sanitizeFilename(companyName)}_brief.pdf`
  
  const options = {
    margin: 10,
    filename: filename,
    image: { type: 'jpeg', quality: 0.98 },
    html2canvas: { scale: 2, useCORS: true },
    jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' as const }
  }
  
  await html2pdf().set(options).from(container).save()
}

/**
 * Export content as Word document (.docx)
 * Uses docx library for generation
 */
export async function exportAsDocx(
  content: string, 
  companyName: string,
  title: string
): Promise<void> {
  // Document children (can be Paragraph or Table)
  const children: (Paragraph | Table)[] = []
  
  // Title - large blue header
  children.push(
    new Paragraph({
      children: [
        new TextRun({
          text: title,
          bold: true,
          size: 56, // 28pt
          color: '1e40af', // Blue
        }),
      ],
      heading: HeadingLevel.TITLE,
      spacing: { after: 120 },
    })
  )
  
  // Subtitle - gray text
  children.push(
    new Paragraph({
      children: [
        new TextRun({
          text: `Research Brief • ${new Date().toLocaleDateString()}`,
          size: 24, // 12pt
          color: '64748b', // Gray
        }),
      ],
      spacing: { after: 400 },
    })
  )
  
  // Parse content
  const lines = content.split('\n')
  let i = 0
  
  while (i < lines.length) {
    const line = lines[i]
    const trimmedLine = line.trim()
    
    // Empty line
    if (!trimmedLine) {
      children.push(new Paragraph({ spacing: { after: 200 } }))
      i++
      continue
    }
    
    // Check if this is the start of a table
    if (trimmedLine.includes('|') && i + 1 < lines.length && lines[i + 1].includes('|') && lines[i + 1].includes('-')) {
      // Collect all table lines
      const tableLines: string[] = []
      while (i < lines.length && lines[i].includes('|')) {
        tableLines.push(lines[i])
        i++
      }
      
      // Create Word table
      const table = createWordTable(tableLines)
      if (table) {
        children.push(new Paragraph({ spacing: { after: 100 } })) // Space before
        children.push(table)
        children.push(new Paragraph({ spacing: { after: 200 } })) // Space after
      }
      continue
    }
    
    // H1
    if (trimmedLine.startsWith('# ') && !trimmedLine.startsWith('## ')) {
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: trimmedLine.slice(2),
              bold: true,
              size: 44, // 22pt
              color: '1e293b',
            }),
          ],
          heading: HeadingLevel.HEADING_1,
          spacing: { before: 400, after: 200 },
        })
      )
    }
    // H2
    else if (trimmedLine.startsWith('## ') && !trimmedLine.startsWith('### ')) {
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: trimmedLine.slice(3),
              bold: true,
              size: 36, // 18pt
              color: '334155',
            }),
          ],
          heading: HeadingLevel.HEADING_2,
          spacing: { before: 320, after: 160 },
        })
      )
    }
    // H3
    else if (trimmedLine.startsWith('### ')) {
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: trimmedLine.slice(4),
              bold: true,
              size: 28, // 14pt
              color: '475569',
            }),
          ],
          heading: HeadingLevel.HEADING_3,
          spacing: { before: 240, after: 120 },
        })
      )
    }
    // Bullet point
    else if (trimmedLine.startsWith('- ') || trimmedLine.startsWith('* ')) {
      children.push(
        new Paragraph({
          children: parseFormattedText(trimmedLine.slice(2)),
          bullet: { level: 0 },
          spacing: { after: 80 },
          indent: { left: convertInchesToTwip(0.25) },
        })
      )
    }
    // Numbered list
    else if (/^\d+\.\s/.test(trimmedLine)) {
      const num = trimmedLine.match(/^\d+/)?.[0] || '1'
      const text = trimmedLine.replace(/^\d+\.\s/, '')
      children.push(
        new Paragraph({
          children: [
            new TextRun({ text: num + '. ', bold: true, size: 24 }),
            ...parseFormattedText(text),
          ],
          spacing: { after: 80 },
          indent: { left: convertInchesToTwip(0.25) },
        })
      )
    }
    // Regular paragraph
    else {
      children.push(
        new Paragraph({
          children: parseFormattedText(trimmedLine),
          spacing: { after: 160 },
        })
      )
    }
    
    i++
  }
  
  // Spacer before footer
  children.push(new Paragraph({ spacing: { before: 400 } }))
  
  // Footer - centered, gray, italic
  children.push(
    new Paragraph({
      children: [
        new TextRun({
          text: `Generated by DealMotion • ${new Date().toLocaleDateString()}`,
          size: 20, // 10pt
          italics: true,
          color: '94a3b8',
        }),
      ],
      alignment: AlignmentType.CENTER,
    })
  )
  
  // Create document
  const doc = new Document({
    styles: {
      default: {
        document: {
          run: {
            font: 'Calibri',
            size: 24,
          },
        },
      },
    },
    sections: [
      {
        children: children,
      },
    ],
  })
  
  // Generate and save
  const buffer = await Packer.toBlob(doc)
  const filename = `${sanitizeFilename(companyName)}_brief.docx`
  saveAs(buffer, filename)
}

/**
 * Create a Word Table from markdown table lines
 */
function createWordTable(tableLines: string[]): Table | null {
  if (tableLines.length < 2) return null
  
  // Parse header row
  const headerLine = tableLines[0]
  const headers = headerLine
    .split('|')
    .map(cell => cell.trim())
    .filter(cell => cell.length > 0)
  
  if (headers.length === 0) return null
  
  // Parse data rows (skip separator line at index 1)
  const dataRows: string[][] = []
  for (let i = 2; i < tableLines.length; i++) {
    const line = tableLines[i]
    if (!line.includes('|')) break
    if (/^[\s\-|:]+$/.test(line.trim())) continue // Skip separator lines
    
    const cells = line
      .split('|')
      .map(cell => cell.trim())
      .filter(cell => cell !== '')
    
    if (cells.length > 0) {
      dataRows.push(cells)
    }
  }
  
  // Calculate column width
  const colWidth = Math.floor(9000 / headers.length) // ~100% width divided by columns
  
  // Create table rows
  const rows: TableRow[] = []
  
  // Header row with blue background
  rows.push(
    new TableRow({
      tableHeader: true,
      children: headers.map(header => 
        new TableCell({
          width: { size: colWidth, type: WidthType.DXA },
          shading: { fill: '1e40af' }, // Blue background
          children: [
            new Paragraph({
              spacing: { before: 80, after: 80 },
              children: [
                new TextRun({
                  text: header.replace(/\*\*/g, '').replace(/\*/g, ''),
                  bold: true,
                  size: 22,
                  color: 'ffffff', // White text
                }),
              ],
            }),
          ],
        })
      ),
    })
  )
  
  // Data rows with alternating colors
  for (let rowIdx = 0; rowIdx < dataRows.length; rowIdx++) {
    const row = dataRows[rowIdx]
    const isEvenRow = rowIdx % 2 === 0
    
    rows.push(
      new TableRow({
        children: row.map(cell =>
          new TableCell({
            width: { size: colWidth, type: WidthType.DXA },
            shading: { fill: isEvenRow ? 'f8fafc' : 'ffffff' }, // Alternating light gray/white
            children: [
              new Paragraph({
                spacing: { before: 60, after: 60 },
                children: parseFormattedText(cell),
              }),
            ],
          })
        ),
      })
    )
  }
  
  // Create table with subtle borders
  return new Table({
    width: { size: 100, type: WidthType.PERCENTAGE },
    rows: rows,
    borders: {
      top: { style: BorderStyle.SINGLE, size: 4, color: 'cbd5e1' },
      bottom: { style: BorderStyle.SINGLE, size: 4, color: 'cbd5e1' },
      left: { style: BorderStyle.SINGLE, size: 4, color: 'cbd5e1' },
      right: { style: BorderStyle.SINGLE, size: 4, color: 'cbd5e1' },
      insideHorizontal: { style: BorderStyle.SINGLE, size: 4, color: 'e2e8f0' },
      insideVertical: { style: BorderStyle.SINGLE, size: 4, color: 'e2e8f0' },
    },
  })
}

/**
 * Parse text with bold/italic markdown formatting into TextRuns
 */
function parseFormattedText(text: string): TextRun[] {
  const runs: TextRun[] = []
  const parts = text.split(/(\*\*.*?\*\*|\*.*?\*)/g)
  
  for (const part of parts) {
    if (!part) continue
    
    if (part.startsWith('**') && part.endsWith('**')) {
      runs.push(new TextRun({
        text: part.slice(2, -2),
        bold: true,
        size: 24,
      }))
    } else if (part.startsWith('*') && part.endsWith('*')) {
      runs.push(new TextRun({
        text: part.slice(1, -1),
        italics: true,
        size: 24,
      }))
    } else {
      runs.push(new TextRun({
        text: part,
        size: 24,
      }))
    }
  }
  
  return runs.length > 0 ? runs : [new TextRun({ text, size: 24 })]
}

// ============================================================
// PDF Export Helpers
// ============================================================

/**
 * Parse markdown tables and return array of table objects
 */
interface ParsedTable {
  headers: string[]
  rows: string[][]
}

function parseMarkdownTable(tableLines: string[]): ParsedTable | null {
  if (tableLines.length < 2) return null
  
  // Parse header row
  const headerLine = tableLines[0]
  const headers = headerLine
    .split('|')
    .map(cell => cell.trim())
    .filter(cell => cell.length > 0)
  
  if (headers.length === 0) return null
  
  // Skip separator line (index 1) and parse data rows
  const rows: string[][] = []
  for (let i = 2; i < tableLines.length; i++) {
    const line = tableLines[i]
    if (!line.includes('|')) break
    
    const cells = line
      .split('|')
      .map(cell => cell.trim())
      .filter(cell => cell !== '')
    
    if (cells.length > 0) {
      rows.push(cells)
    }
  }
  
  return { headers, rows }
}

/**
 * Convert a parsed table to styled HTML
 */
function tableToHtml(table: ParsedTable): string {
  const tableStyle = `
    width: 100%;
    border-collapse: collapse;
    margin: 16px 0;
    font-size: 13px;
  `.replace(/\s+/g, ' ').trim()
  
  const thStyle = `
    background-color: #f8fafc;
    border: 1px solid #e2e8f0;
    padding: 10px 12px;
    text-align: left;
    font-weight: 600;
    color: #1e293b;
  `.replace(/\s+/g, ' ').trim()
  
  const tdStyle = `
    border: 1px solid #e2e8f0;
    padding: 10px 12px;
    color: #334155;
  `.replace(/\s+/g, ' ').trim()
  
  let html = `<table style="${tableStyle}">`
  
  // Header row
  html += '<thead><tr>'
  for (const header of table.headers) {
    const formattedHeader = header
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.*?)\*/g, '<em>$1</em>')
    html += `<th style="${thStyle}">${formattedHeader}</th>`
  }
  html += '</tr></thead>'
  
  // Data rows
  html += '<tbody>'
  for (const row of table.rows) {
    html += '<tr>'
    for (const cell of row) {
      const formattedCell = cell
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>')
      html += `<td style="${tdStyle}">${formattedCell}</td>`
    }
    html += '</tr>'
  }
  html += '</tbody>'
  
  html += '</table>'
  return html
}

/**
 * Convert markdown content to HTML for PDF generation
 * Includes table support
 */
function markdownToHtml(markdown: string): string {
  const lines = markdown.split('\n')
  const result: string[] = []
  let i = 0
  
  while (i < lines.length) {
    const line = lines[i]
    
    // Check if this is the start of a table
    if (line.includes('|') && i + 1 < lines.length && lines[i + 1].includes('|') && lines[i + 1].includes('-')) {
      // Collect all table lines
      const tableLines: string[] = []
      while (i < lines.length && lines[i].includes('|')) {
        tableLines.push(lines[i])
        i++
      }
      
      // Parse and convert table
      const table = parseMarkdownTable(tableLines)
      if (table) {
        result.push(tableToHtml(table))
      } else {
        result.push(...tableLines)
      }
      continue
    }
    
    // Process non-table line
    let processedLine = line
    
    // Headers
    if (processedLine.startsWith('### ')) {
      processedLine = `<h3 style="color: #1e293b; font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">${processedLine.slice(4)}</h3>`
    } else if (processedLine.startsWith('## ')) {
      processedLine = `<h2 style="color: #1e293b; font-size: 20px; font-weight: 600; margin: 28px 0 16px 0; padding-bottom: 8px; border-bottom: 1px solid #e2e8f0;">${processedLine.slice(3)}</h2>`
    } else if (processedLine.startsWith('# ')) {
      processedLine = `<h1 style="color: #1e293b; font-size: 24px; font-weight: 700; margin: 32px 0 16px 0;">${processedLine.slice(2)}</h1>`
    } 
    // Bullet lists
    else if (/^\s*[-*]\s+/.test(processedLine)) {
      const text = processedLine.replace(/^\s*[-*]\s+/, '')
      processedLine = `<li style="margin: 4px 0; margin-left: 20px;">${text}</li>`
    }
    // Numbered lists
    else if (/^\d+\.\s+/.test(processedLine)) {
      const text = processedLine.replace(/^\d+\.\s+/, '')
      processedLine = `<li style="margin: 4px 0; margin-left: 20px;">${text}</li>`
    }
    // Empty lines
    else if (processedLine.trim() === '') {
      processedLine = '<br/>'
    }
    // Regular paragraphs
    else if (!processedLine.startsWith('<')) {
      processedLine = `<p style="margin: 12px 0;">${processedLine}</p>`
    }
    
    // Apply inline formatting (bold/italic)
    processedLine = processedLine
      .replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>')
      .replace(/\*\*(.*?)\*\*/g, '<strong style="font-weight: 600;">$1</strong>')
      .replace(/\*(.*?)\*/g, '<em>$1</em>')
    
    result.push(processedLine)
    i++
  }
  
  // Wrap consecutive list items in ul
  let html = result.join('\n')
  html = html.replace(/(<li[^>]*>.*?<\/li>\n?)+/g, (match) => {
    return `<ul style="margin: 12px 0; padding-left: 0;">${match}</ul>`
  })
  
  // Clean up
  html = html.replace(/<br\/>\s*<br\/>/g, '<br/>')
  html = html.replace(/<p style="margin: 12px 0;"><\/p>/g, '')
  
  return html
}
